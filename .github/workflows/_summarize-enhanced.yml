name: Summarize Enhanced

on:
  workflow_call:
    inputs:
      post_mode:
        type: string
        required: true
      control_repo_ref:
        type: string
        required: true
    secrets:
      PAT_TOKEN:
        required: true
      GEMINI_API_KEY:
        required: true

jobs:
  summarize:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Download all batch artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./
          pattern: review-batch-*
          merge-multiple: false
          create-artifact-meta: false
          if-no-files-found: warn

      - name: Validate downloaded batch artifacts
        shell: bash
        run: |
          echo "üîç Validating downloaded batch artifacts..."
          
          # Check current directory contents (only batch-related files)
          echo "Current directory contents (batch artifacts only):"
          ls -la review-batch-* 2>/dev/null || echo "‚ö†Ô∏è  WARNING: No batch directories found"
          echo "All files in current directory:"
          ls -la || echo "‚ö†Ô∏è  WARNING: ls command failed"
          
          # Check for batch directories with error handling
          BATCH_DIRS=$(find . -name "review-batch-*" -type d | wc -l 2>/dev/null || echo '0')
          echo "Found $BATCH_DIRS batch directories"
          
          if [ "$BATCH_DIRS" -eq 0 ]; then
            echo "‚ùå ERROR: No batch artifacts found for consolidation"
            echo "Expected directories: review-batch-*"
            exit 1
          fi
          
          # Validate each batch directory structure
          TOTAL_FILES=0
          TOTAL_BATCHES=0
          
          for batch_dir in review-batch-*; do
            if [ -d "$batch_dir" ]; then
              TOTAL_BATCHES=$((TOTAL_BATCHES + 1))
              echo "Validating batch directory: $batch_dir"
              
              # Check for flat structure (no nested reviews directory)
              if [ -d "$batch_dir/reviews" ]; then
                echo "‚ùå ERROR: Found nested 'reviews' directory in $batch_dir - expected flat structure"
                exit 1
              fi
              
              # Check for summary.json
              if [ ! -f "$batch_dir/summary.json" ]; then
                echo "‚ùå ERROR: summary.json not found in $batch_dir"
                exit 1
              fi
              
              # Safely check if jq is available
              if ! command -v jq &> /dev/null; then
                echo "‚ö†Ô∏è  WARNING: jq not available, skipping JSON validation for $batch_dir"
                echo "  ‚úÖ $batch_dir: summary.json exists (validation skipped)"
              else
                # Validate summary.json
                if ! jq -e '.' "$batch_dir/summary.json" > /dev/null 2>&1; then
                  echo "‚ùå ERROR: Invalid JSON in $batch_dir/summary.json"
                  exit 1
                fi
              fi
              
              # Count review files with error handling
              REVIEW_FILES=$(find "$batch_dir" -name "*.md" -type f | grep -v summary.json | wc -l 2>/dev/null || echo '0')
              TOTAL_FILES=$((TOTAL_FILES + REVIEW_FILES))
              
              echo "  ‚úÖ $batch_dir: $REVIEW_FILES review files + summary.json"
              
              # Check for prompt-log directory
              if [ -d "$batch_dir/prompt-log" ]; then
                PROMPT_COUNT=$(find "$batch_dir/prompt-log" -name "*.md" -type f | wc -l 2>/dev/null || echo '0')
                echo "  üìù $batch_dir: $PROMPT_COUNT debug prompt files"
              fi
            fi
          done
          
          echo "‚úÖ Downloaded artifacts validation passed:"
          echo "   - Total batches: $TOTAL_BATCHES"
          echo "   - Total review files: $TOTAL_FILES"
          echo "   - All batches have flat structure"
          echo "   - All batches have valid summary.json"

      - name: Consolidate reviews
        uses: softlink-dev/.github/.github/actions/consolidate-batches@main
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          workspace: ${{ github.workspace }}

      - name: Validate consolidation output
        shell: bash
        run: |
          echo "üîç Validating consolidation output..."
          
          # Check current directory contents
          echo "Current directory contents:"
          ls -la || echo "‚ö†Ô∏è  WARNING: ls command failed"
          
          # Check for expected consolidation files
          if [ ! -f "consolidate_review.md" ]; then
            echo "‚ùå ERROR: consolidate_review.md not found"
            exit 1
          fi
          
          if [ ! -f "consolidate_summary.md" ]; then
            echo "‚ùå ERROR: consolidate_summary.md not found"
            exit 1
          fi
          
          # Check file sizes with error handling
          REVIEW_SIZE=$(wc -c < consolidate_review.md 2>/dev/null || echo '0')
          SUMMARY_SIZE=$(wc -c < consolidate_summary.md 2>/dev/null || echo '0')
          
          echo "‚úÖ Consolidation output validation passed:"
          echo "   - consolidate_review.md: $REVIEW_SIZE bytes"
          echo "   - consolidate_summary.md: $SUMMARY_SIZE bytes"
          
          # Check for minimum content
          if [ "$REVIEW_SIZE" -lt 100 ]; then
            echo "‚ö†Ô∏è  WARNING: consolidate_review.md seems very small ($REVIEW_SIZE bytes)"
          fi
          
          if [ "$SUMMARY_SIZE" -lt 50 ]; then
            echo "‚ö†Ô∏è  WARNING: consolidate_summary.md seems very small ($SUMMARY_SIZE bytes)"
          fi
          
          echo "‚úÖ Consolidation validation completed successfully"

      - name: Commit review results into PR branch (if allowed and requested)
        if: |
          success() &&
          (github.event_name == 'pull_request') &&
          ((inputs.post_mode == 'commit') || (inputs.post_mode == 'both'))
        env:
          PAT: ${{ secrets.PAT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          # Debug: Log the current state
          echo "::debug::Starting commit step"
          echo "::debug::Event name: ${{ github.event_name }}"
          echo "::debug::Post mode: ${{ inputs.post_mode }}"
          echo "::debug::PR number: ${{ github.event.pull_request.number }}"
          echo "::debug::PR head ref: ${{ github.event.pull_request.head.ref }}"

          OUT_DIR=".github/review-results/PR-${{ github.event.pull_request.number }}"
          echo "::debug::Creating output directory: $OUT_DIR"
          mkdir -p "$OUT_DIR"

          echo "::debug::Checking if consolidate files exist"
          ls -la consolidate_*.md || echo "::debug::consolidate files not found"

          echo "::debug::Copying consolidate files to $OUT_DIR/"
          if [ -f "consolidate_review.md" ]; then
            cp consolidate_review.md "$OUT_DIR/DETAILED-REVIEW.md"
          fi
          if [ -f "consolidate_summary.md" ]; then
            cp consolidate_summary.md "$OUT_DIR/SUMMARY.md"
          fi
          
          # Copy debug prompts from batch artifacts to prompt-log folder
          echo "::debug::Copying debug prompts from batch artifacts"
          mkdir -p "$OUT_DIR/prompt-log"
          for batch_dir in review-batch-*; do
            if [ -d "$batch_dir" ] && [ -d "$batch_dir/prompt-log" ]; then
              echo "::debug::Copying prompts from $batch_dir/prompt-log/"
              cp -r "$batch_dir/prompt-log/"* "$OUT_DIR/prompt-log/" 2>/dev/null || echo "::debug::No prompt files found in $batch_dir"
            fi
          done

          echo "::debug::Files created in $OUT_DIR:"
          ls -la "$OUT_DIR"/

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          current_branch="${{ github.event.pull_request.head.ref }}"
          retries=3
          while [ $retries -gt 0 ]; do
            git remote set-url origin "https://x-access-token:$PAT@github.com/${{ github.repository }}.git"
            git fetch origin "$current_branch"
            git checkout "$current_branch"
            git pull --rebase origin "$current_branch" || git pull origin "$current_branch"
            
            git add "$OUT_DIR/"
            if git diff --staged --quiet; then
              echo "::debug::No changes to commit"
              break
            fi
            
            if git commit -m "ü§ñ AI Code Review Results - PR #${{ github.event.pull_request.number }}

          Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          - Detailed review: $OUT_DIR/DETAILED-REVIEW.md
          - Summary: $OUT_DIR/SUMMARY.md
          - Debug prompts: $OUT_DIR/prompt-log/PROMPT-*.md
          
          Files committed to: $OUT_DIR/"; then
              echo "::debug::Commit successful"
              if git push origin "$current_branch"; then
                echo "::debug::Push successful"
                echo "‚úÖ Review results committed to PR branch"
                echo "üìÅ Files available at: https://github.com/${{ github.repository }}/blob/$current_branch/$OUT_DIR/"
                break
              else
                echo "::debug::Push failed, retrying..."
                retries=$((retries - 1))
                sleep 5
              fi
            else
              echo "::debug::Commit failed, retrying..."
              retries=$((retries - 1))
              sleep 5
            fi
          done

          if [ $retries -eq 0 ]; then
            echo "‚ùå Failed to commit review results after 3 retries"
            exit 1
          fi

      - name: Post review as PR comment
        if: |
          github.event_name == 'pull_request' &&
          (inputs.post_mode == 'commit' || inputs.post_mode == 'both' || inputs.post_mode == 'comment')
        env:
          PAT: ${{ secrets.PAT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          # Check if detailed review exists and determine what to post
          if [ -f "consolidate_review.md" ]; then
            DETAILED_CONTENT=$(cat consolidate_review.md)
            DETAILED_LENGTH=${#DETAILED_CONTENT}
            
            # GitHub comment limit is 65535 characters
            MAX_LENGTH=65000
            
            if [ $DETAILED_LENGTH -gt $MAX_LENGTH ]; then
              echo "Detailed review is too long ($DETAILED_LENGTH chars), using summary instead"
              
              if [ -f "consolidate_summary.md" ]; then
                SUMMARY_CONTENT=$(cat consolidate_summary.md)
                COMMENT_BODY="## ü§ñ AI Code Review Results (Summary)

                $SUMMARY_CONTENT

                ---
                *Detailed review was too long for comment. Full review available in artifacts and committed files.*"
              else
                # Fallback: truncate detailed review
                REPORT_CONTENT="${DETAILED_CONTENT:0:$((MAX_LENGTH-200))}...\n\n*[Review truncated due to length limits. Full review available in artifacts and committed files.]*"
                COMMENT_BODY="## ü§ñ AI Code Review Results

                $REPORT_CONTENT

                ---
                *Review generated by Gemini AI. Full detailed review available in the workflow artifacts.*"
              fi
            else
              # Use full detailed review
              COMMENT_BODY="## ü§ñ AI Code Review Results

              $DETAILED_CONTENT

              ---
              *Review generated by Gemini AI. Full detailed review available in the workflow artifacts.*"
            fi

            # Post comment using GitHub API
            curl -X POST \
              -H "Authorization: token $PAT" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{\"body\":$(echo "$COMMENT_BODY" | jq -Rs .)}" \
              "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"
          else
            echo "No detailed review found to post as comment"
          fi
