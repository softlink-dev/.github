name: Gemini PR Review

on:
  workflow_call:
    inputs:
      model:
        description: "Gemini model to use"
        type: string
        default: gemini-2.5-pro
      max_files:
        description: "Max files per commit to review"
        type: string
        default: "25"
      max_diff_lines:
        description: "Max unified diff lines to include (per file)"
        type: string
        default: "4000"
      exclude_regex:
        description: "Regex of files/paths to skip"
        type: string
        default: '(^|/)(dist|build|node_modules|coverage|out|bin|obj|target|vendor)/|\.lock$|\.min\.(js|css)$|\.map$|\.png$|\.jpe?g$|\.gif$|\.svg$|\.pdf$|\.zip$|\.tar$|\.gz$|\.7z$|\.ico$|\.bmp$'
      policy_path:
        description: "Path to repo/org review policy file"
        type: string
        default: '.github/review/REVIEW_POLICY.md'
      control_repo_ref:
        description: "Branch/ref of the org control repo (.github)"
        type: string
        default: main

      # New tunables (safe defaults)
      full_file_threshold_lines:
        description: "Max lines to include full post-change file"
        type: string
        default: "1200"
      window_before:
        description: "Lines before each hunk in windowed mode"
        type: string
        default: "60"
      window_after:
        description: "Lines after each hunk in windowed mode"
        type: string
        default: "40"
      merge_gap_tolerance:
        description: "Merge windows if gap ≤ this many lines"
        type: string
        default: "10"
      max_windowed_lines:
        description: "Max total excerpt lines across windows"
        type: string
        default: "1200"
      max_commits:
        description: "Safety cap on commits per PR to process"
        type: string
        default: "100"
      post_mode:
        description: "Where to publish results: artifact_only | commit | both"
        type: string
        default: "artifact_only"

    secrets:
      GEMINI_API_KEY:
        required: true
      PAT_TOKEN:
        required: true

concurrency:
  group: pr-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  prepare:
    name: Build review manifest
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      items: ${{ steps.manifest.outputs.items }}
      policy_found: ${{ steps.policy.outputs.found }}
      policy_scope: ${{ steps.policy.outputs.scope }}
      policy_path_resolved: ${{ steps.policy.outputs.path }}
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Checkout org .github control repo (for default policy)
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          ref: ${{ inputs.control_repo_ref }}
          path: __org_control
          fetch-depth: 1
          token: ${{ secrets.PAT_TOKEN }}

      - name: Resolve base/head SHAs
        id: shas
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "base=${{ github.event.pull_request.base.sha }}" >> $GITHUB_OUTPUT
            echo "head=${{ github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
          else
            git fetch origin "${{ github.event.repository.default_branch || 'main' }}"
            echo "base=$(git rev-parse "origin/${{ github.event.repository.default_branch || 'main' }}")" >> $GITHUB_OUTPUT
            echo "head=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Locate review policy (repo override or org default)
        id: policy
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ inputs.policy_path }}" ]; then
            echo "path=${{ inputs.policy_path }}" >> "$GITHUB_OUTPUT"
            echo "scope=repo" >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
          elif [ -f "__org_control/${{ inputs.policy_path }}" ]; then
            echo "path=__org_control/${{ inputs.policy_path }}" >> "$GITHUB_OUTPUT"
            echo "scope=org" >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate manifest (commits → files)
        id: manifest
        uses: actions/github-script@v7
        env:
          EXCLUDE_REGEX: ${{ inputs.exclude_regex }}
          MAX_FILES: ${{ inputs.max_files }}
          MAX_COMMITS: ${{ inputs.max_commits }}
        with:
          script: |
            const exclude = new RegExp(process.env.EXCLUDE_REGEX || '');
            const perCommitCap = parseInt(process.env.MAX_FILES || '25', 10);
            const maxCommits = parseInt(process.env.MAX_COMMITS || '100', 10);

            const {owner, repo, number} = context.issue;
            if (!number) {
              core.setFailed('This workflow must run on a PR (pull_request event or called with PR context).');
              return;
            }

            // Commits in PR (base→head)
            let commits = await github.paginate(github.rest.pulls.listCommits, {owner, repo, pull_number: number});
            if (commits.length > maxCommits) commits = commits.slice(0, maxCommits);

            const items = [];
            for (const c of commits) {
              const sha = c.sha;
              const commit = await github.rest.repos.getCommit({owner, repo, ref: sha});
              let count = 0;
              for (const f of (commit.data.files || [])) {
                const path = f.filename;
                if (exclude.test(path)) continue;
                if (!['added','modified','renamed','changed'].includes(f.status)) continue;
                const isBinary = (f.patch == null); // GitHub omits 'patch' for binary
                const item = {
                  sha,
                  path,
                  status: f.status,
                  is_binary: isBinary,
                  renamed_from: f.previous_filename || null,
                  additions: f.additions || 0,
                  deletions: f.deletions || 0,
                  patch: f.patch || null
                };
                items.push(item);
                count++;
                if (count >= perCommitCap) break;
              }
            }
            core.setOutput('items', JSON.stringify(items, null, 2));

      - name: Write manifest file
        shell: bash
        run: |
          printf '%s' '${{ steps.manifest.outputs.items }}' > "${RUNNER_TEMP}/manifest.json"

      - name: Upload manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: review-manifest
          path: ${{ runner.temp }}/manifest.json

  review:
    name: Review ${{ matrix.item.path }} @ ${{ matrix.item.sha }}
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    strategy:
      max-parallel: 4
      fail-fast: false
      matrix:
        item: ${{ fromJson(needs.prepare.outputs.items || '[]') }}
    env:
      GEMINI_MODEL: ${{ inputs.model }}
      MAX_DIFF_LINES: ${{ inputs.max_diff_lines }}
      FULL_FILE_THRESHOLD_LINES: ${{ inputs.full_file_threshold_lines }}
      WINDOW_BEFORE: ${{ inputs.window_before }}
      WINDOW_AFTER: ${{ inputs.window_after }}
      MERGE_GAP_TOLERANCE: ${{ inputs.merge_gap_tolerance }}
      MAX_WINDOWED_LINES: ${{ inputs.max_windowed_lines }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout org .github control repo (for default policy)
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          ref: ${{ inputs.control_repo_ref }}
          path: __org_control
          fetch-depth: 1
          token: ${{ secrets.PAT_TOKEN }}

      - name: Re-locate review policy (cheap repeat)
        id: policy
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ inputs.policy_path }}" ]; then
            echo "path=${{ inputs.policy_path }}" >> "$GITHUB_OUTPUT"
            echo "scope=repo" >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
          elif [ -f "__org_control/${{ inputs.policy_path }}" ]; then
            echo "path=__org_control/${{ inputs.policy_path }}" >> "$GITHUB_OUTPUT"
            echo "scope=org" >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare per-file inputs (diff + post-change content)
        id: context
        shell: bash
        env:
          ITEM_JSON: ${{ toJson(matrix.item) }}
        run: |
          set -euo pipefail
          mkdir -p work
          printf '%s\n' "${ITEM_JSON}" > work/item.json

          # Extract fields
          SHA="$(jq -r '.sha' work/item.json)"
          PATHNEW="$(jq -r '.path' work/item.json)"
          STATUS="$(jq -r '.status' work/item.json)"
          ISBIN="$(jq -r '.is_binary' work/item.json)"
          jq -r '.patch // empty' work/item.json > work/patch.diff || true

          # If no patch (binary or API omitted), try reconstructing a per-file unified diff (unified=0)
          if [ ! -s work/patch.diff ] && [ "${ISBIN}" != "true" ]; then
            git show --no-color --unified=0 "${SHA}" -- "${PATHNEW}" > work/patch.diff || true
          fi

          # Truncate diff to MAX_DIFF_LINES
          if [ -s work/patch.diff ]; then
            head -n "${MAX_DIFF_LINES}" work/patch.diff > work/patch.trim && mv work/patch.trim work/patch.diff
          fi

          # Get post-change file content (new version at this commit)
          if [ "${ISBIN}" = "true" ]; then
            : # binary - skip content extraction
          else
            git show "${SHA}:${PATHNEW}" > work/file.txt 2>/dev/null || true
          fi

          # Decide context packing mode
          MODE="diff_only"
          FILE_LINES="0"
          if [ -f work/file.txt ]; then
            FILE_LINES=$(wc -l < work/file.txt | tr -d ' ')
            if [ "$FILE_LINES" -le "${FULL_FILE_THRESHOLD_LINES}" ]; then
              MODE="full"
            else
              MODE="windowed"
            fi
          fi

          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "path=${PATHNEW}" >> $GITHUB_OUTPUT
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "mode=${MODE}" >> $GITHUB_OUTPUT
          echo "file_lines=${FILE_LINES}" >> $GITHUB_OUTPUT

      - name: Build excerpts for windowed mode (merge overlapping ranges)
        if: steps.context.outputs.mode == 'windowed'
        shell: bash
        run: |
          set -euo pipefail
          # Parse +c,d from @@ -a,b +c,d @@ headers
          grep -E '^@@ ' work/patch.diff | \
          awk -v wb="${WINDOW_BEFORE}" -v wa="${WINDOW_AFTER}" '
            {
              # header format: @@ -a,b +c,d @@
              match($0, /\+([0-9]+),?([0-9]*)/, m)
              c = m[1]; d = (m[2] == "" ? 1 : m[2])
              start = c - wb; if (start < 1) start = 1
              end = c + d - 1 + wa
              print start " " end
            }' | sort -n > work/windows.raw || true

          if [ ! -s work/windows.raw ]; then
            echo "mode=diff_only" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Merge windows when gap ≤ MERGE_GAP_TOLERANCE
          awk -v gap="${MERGE_GAP_TOLERANCE}" '
            NR==1 { s=$1; e=$2; next }
            {
              if ($1 <= e + gap) {
                if ($2 > e) e=$2
              } else {
                print s " " e
                s=$1; e=$2
              }
            }
            END { if (s!="") print s " " e }
          ' work/windows.raw > work/windows.merged

          # Cap total excerpt lines
          TOTAL=0
          : > work/windows.final
          while read -r s e; do
            if [ -z "$s" ] || [ -z "$e" ]; then continue; fi
            seg=$(( e - s + 1 ))
            if [ $(( TOTAL + seg )) -gt "${MAX_WINDOWED_LINES}" ]; then
              remaining=$(( MAX_WINDOWED_LINES - TOTAL ))
              if [ "$remaining" -le 0 ]; then break; fi
              e=$(( s + remaining - 1 ))
              seg=$remaining
            fi
            echo "$s $e" >> work/windows.final
            TOTAL=$(( TOTAL + seg ))
            if [ "$TOTAL" -ge "${MAX_WINDOWED_LINES}" ]; then break; fi
          done < work/windows.merged

          # Extract the merged windows from file.txt with banners
          : > work/excerpts.txt
          while read -r s e; do
            echo "--- BEGIN EXCERPT [lines ${s}-${e}] ---" >> work/excerpts.txt
            awk -v S="$s" -v E="$e" 'NR>=S && NR<=E { print }' work/file.txt >> work/excerpts.txt
            echo "--- END EXCERPT ---" >> work/excerpts.txt
          done < work/windows.final

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini CLI
        run: npm install -g @google/gemini-cli

      - name: Build prompt and call Gemini
        id: ai
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ env.GEMINI_MODEL }}
        shell: bash
        run: |
          set -euo pipefail
          SHA="${{ steps.context.outputs.sha }}"
          PATHNEW="${{ steps.context.outputs.path }}"
          STATUS="${{ steps.context.outputs.status }}"
          MODE="${{ steps.context.outputs.mode }}"
          FILE_LINES="${{ steps.context.outputs.file_lines }}"

          # Build prompt
          {
            echo "You are reviewing exactly ONE file in a PR."
            echo
            echo "Repository: ${{ github.repository }}"
            echo "Commit: ${SHA}"
            echo "File: ${PATHNEW}"
            echo "Status: ${STATUS}"
            echo "Context-Mode: ${MODE}${FILE_LINES:+ (file lines: ${FILE_LINES})}"
            echo
            echo "STRICT RULES:"
            echo "- Review ONLY this file at this commit."
            echo "- Use ONLY the unified diff below and the provided post-change content (if any)."
            echo "- If cross-file context is needed, reply: 'Out of scope: requires cross-file context.'"
            echo "- Be specific with line references and provide actionable, testable suggestions."
            echo
            if [ "${{ steps.policy.outputs.found }}" = "true" ]; then
              echo "--- BEGIN REVIEW POLICY (${{ steps.policy.outputs.scope }}) ---"
              cat "${{ steps.policy.outputs.path }}"
              echo "--- END REVIEW POLICY ---"
              echo
            fi
            echo "--- BEGIN DIFF (file-scoped) ---"
            if [ -s work/patch.diff ]; then
              cat work/patch.diff
            else
              echo "(No diff content available for this file.)"
            fi
            echo "--- END DIFF ---"
            echo
            if [ "${MODE}" = "full" ] && [ -s work/file.txt ]; then
              echo "--- BEGIN POST-CHANGE CONTENT (FULL) ---"
              cat work/file.txt
              echo "--- END POST-CHANGE CONTENT ---"
            elif [ "${MODE}" = "windowed" ] && [ -s work/excerpts.txt ]; then
              echo "--- BEGIN POST-CHANGE EXCERPTS (WINDOWED) ---"
              cat work/excerpts.txt
              echo "--- END POST-CHANGE EXCERPTS ---"
            else
              echo "(No post-change content included.)"
            fi
          } > prompt.md

          # Run Gemini CLI (single call per file)
          gemini --yolo --model "$GEMINI_MODEL" --prompt "$(cat prompt.md)" > out.body  \
            || gemini --yolo --model "gemini-2.0-pro" --prompt "$(cat prompt.md)" > out.body

          # Wrap with a per-file header for stable aggregation
          mkdir -p reviews/"${SHA}"
          SAFE_PATH="$(printf '%s' "${PATHNEW}" | tr '/\\' '__')"
          OUT="reviews/${SHA}/${SAFE_PATH}.md"
          {
            echo "## ${PATHNEW} @ ${SHA:0:8}"
            echo
            echo "**Mode:** ${MODE}  |  **Lines:** ${FILE_LINES:-0}"
            echo
            cat out.body
            echo
            echo "---"
          } > "${OUT}"

          echo "out=${OUT}" >> $GITHUB_OUTPUT

      - name: Upload per-file artifact
        uses: actions/upload-artifact@v4
        with:
          name: review-${{ matrix.item.sha }}
          path: reviews/${{ steps.context.outputs.sha }}/

  summarize:
    name: Summarize and publish review
    needs: [prepare, review]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout PR head (for optional commit)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Download all review artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-reviews

      - name: Stitch per-commit and PR-level summaries
        id: stitch
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p compiled
          echo "# AI Review Summary for PR #${{ github.event.pull_request.number }}" > compiled/SUMMARY.md
          echo >> compiled/SUMMARY.md

          # Build PR-level report ordered by commit
          if ls all-reviews >/dev/null 2>&1; then
            for d in $(ls -1 all-reviews | grep '^review-' | sed 's/^review-//' | sort); do
              echo "- Commit ${d}" >> compiled/SUMMARY.md
              mkdir -p "compiled/${d}"
              echo "# Commit ${d}" > "compiled/${d}/index.md"
              if ls "all-reviews/review-${d}"/*.md >/dev/null 2>&1; then
                for f in $(ls -1 "all-reviews/review-${d}"/*.md | sort); do
                  cat "$f" >> "compiled/${d}/index.md"
                  echo >> "compiled/${d}/index.md"
                done
              fi
            done
          else
            echo "No review artifacts found." >> compiled/SUMMARY.md
          fi

          {
            echo "# PR-level Review Report"
            echo
            for d in $(ls -1 compiled | grep -v SUMMARY.md | sort); do
              if [ -f "compiled/$d/index.md" ]; then
                echo
                echo "## Commit ${d}"
                echo
                cat "compiled/$d/index.md"
              fi
            done
          } > compiled/PR-REPORT.md

          echo "pr_report=compiled/PR-REPORT.md" >> $GITHUB_OUTPUT

      - name: Upload compiled summary artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-compiled
          path: compiled/

      - name: Commit review results into PR branch (if allowed and requested)
        if: |
          github.event_name == 'pull_request' &&
          !github.event.pull_request.head.repo.fork &&
          (inputs.post_mode == 'commit' || inputs.post_mode == 'both')
        shell: bash
        run: |
          set -euo pipefail
          OUT_DIR=".github/review-results"
          mkdir -p "$OUT_DIR"
          # Copy compiled reports
          cp -r compiled/* "$OUT_DIR"/

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "$OUT_DIR"
          git commit -m "chore: add AI review results for PR #${{ github.event.pull_request.number }} [skip ci]" || echo "No changes to commit"
          git push

      - name: Note fork fallback / artifact-only
        if: |
          github.event_name == 'pull_request' &&
          ( github.event.pull_request.head.repo.fork ||
            inputs.post_mode == 'artifact_only' )
        run: |
          echo "::notice::Results published as workflow artifacts. Commit to branch skipped (fork or artifact_only mode)."
